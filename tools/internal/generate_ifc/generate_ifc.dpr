{
  Copyright 2025-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}
{ Generate Pascal code IFC API. See README.md for details. }

{$I castleconf.inc}

uses SysUtils, Classes, Dom, XmlRead, Generics.Defaults, Generics.Collections,
  {$ifdef FPC} OpenSSLSockets, {$endif} // support HTTPS
  CastleStringUtils, CastleClassUtils, CastleDownload, CastleXmlUtils,
  CastleUtils, CastleFilesUtils;

const
  SchemaUrl = 'https://standards.buildingsmart.org/IFC/RELEASE/IFC4_3/HTML/IFC4X3_ADD2.xsd';
  SchemaFile = 'IFC4X3_ADD2.xsd';
  OutputPath: String = '../../../src/scene/load/ifc/castleifc_ifc_standard_types_autogenerated.inc';
var
  ProcessTypes: TStringList;

{ TIfcType ------------------------------------------------------------------ }

type
  TIfcType = class
    Name: String;
    function DeclareOrder: Integer; virtual;
  end;

function TIfcType.DeclareOrder: Integer;
begin
  Result := 0;
end;

{ TIfcComplexType ----------------------------------------------------------- }

type
  TIfcComplexType = class(TIfcType)
    Base: String;
    BaseInstance: TIfcComplexType;
    function DeclareOrder: Integer; override;
  end;

function TIfcComplexType.DeclareOrder: Integer;
begin
  Result := inherited;
  Inc(Result); // place all classes after simple types like enums
  { This is a recursive call, but shouldn't hang if there are no cycles
    in ancestry tree in XSD. }
  if BaseInstance <> nil then
    Result := Result + 1 + BaseInstance.DeclareOrder;
end;

{ TIfcTypeList -------------------------------------------------------------- }

type
  TIfcTypeList = class({$ifdef FPC}specialize{$endif} TObjectList<TIfcType>)
  public
    { @nil if not found. }
    function Find(const Name: String): TIfcType;
    { Assign TIfcComplexType.BaseInstance where possible. }
    procedure ResolveAncestors;
    { Compare TIfcType to determine order in which they should be declared. }
    function CompareIfcTypes(
      {$ifdef GENERICS_CONSTREF}constref{$else}const{$endif}
      Left, Right: TIfcType): Integer;
    procedure MakeOutput(out OutputInterface, OutputImplementation,
      OutputAddClasses: String);
  end;

  TIfcTypeComparer = specialize TComparer<TIfcType>;

var
  IfcTypes: TIfcTypeList;

function TIfcTypeList.Find(const Name: String): TIfcType;
begin
  for Result in Self do
    if Result.Name = Name then
      Exit;
  Result := nil;
end;

procedure TIfcTypeList.ResolveAncestors;
var
  IfcType: TIfcType;
  ComplexType: TIfcComplexType;
begin
  for IfcType in Self do
    if IfcType is TIfcComplexType then
    begin
      ComplexType := TIfcComplexType(IfcType);
      ComplexType.BaseInstance := Find(ComplexType.Base) as TIfcComplexType;
    end;
end;

function TIfcTypeList.CompareIfcTypes(
  {$ifdef GENERICS_CONSTREF}constref{$else}const{$endif}
  Left, Right: TIfcType): Integer;
begin
  Result := Left.DeclareOrder - Right.DeclareOrder;
end;

procedure TIfcTypeList.MakeOutput(out OutputInterface,
  OutputImplementation, OutputAddClasses: String);

  function IfcClassToPascal(const IfcClassName: String): String;
  begin
    Result := 'T' + PrefixRemove('Ifc:', IfcClassName, true);
  end;

var
  IfcType: TIfcType;
  ComplexType: TIfcComplexType;
begin
  OutputInterface := '';
  OutputImplementation := '';
  OutputAddClasses := '';
  for IfcType in Self do
  begin
    if IfcType is TIfcComplexType then
    begin
      ComplexType := TIfcComplexType(IfcType);
      OutputInterface := OutputInterface + Format(
        '  %s = class(%s)' + NL + '  strict private' + NL, [
          IfcClassToPascal(ComplexType.Name),
          IfcClassToPascal(ComplexType.Base)
        ]);
      // TODO: properties, private and public and published
      OutputInterface := OutputInterface +
        '  end;' + NL + NL;

      OutputAddClasses := OutputAddClasses + Format(
        '  FIfcClasses.Add(%s);' + NL, [
          IfcClassToPascal(ComplexType.Name)
        ]);
    end;
  end;
end;

{ routines ------------------------------------------------------------------ }

procedure DownloadSchema;
var
  SchemaStream: TMemoryStream;
begin
  if FileExists(SchemaFile) then
    Writeln('Schema file exists: ', SchemaFile)
  else
  begin
    Writeln('Schema file does not exist, downloading: ', SchemaFile);
    EnableBlockingDownloads := true;
    SchemaStream := Download(SchemaUrl, [soForceMemoryStream]) as TMemoryStream;
    try
      SchemaStream.SaveToFile(SchemaFile);
    finally FreeAndNil(SchemaStream) end;
  end;
end;

procedure HandleSimpleType(Node: TDomElement);
// var
//   TypeName: String;
begin
  // TypeName := Node.AttributeString('name');
  //Writeln('Simple type: ', TypeName);
end;

procedure HandleComplexType(Node: TDomElement);
var
  TypeName, BaseName: String;
  ComplexContent, Extension: TDomElement;
  ComplexType: TIfcComplexType;
begin
  TypeName := Node.AttributeString('name');
  if ProcessTypes.IndexOf(TypeName) <> -1 then
  begin
    { Sample:
    <xs:complexType name="IfcRailingType">
      <xs:complexContent>
        <xs:extension base="ifc:IfcBuiltElementType">
          <xs:attribute name="PredefinedType" type="ifc:IfcRailingTypeEnum" use="optional"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
    }
    //Writeln('Processing complex type: ', TypeName);
    ComplexContent := Node.Child('xs:complexContent', false, true);
    if ComplexContent <> nil then
    begin
      Extension := ComplexContent.Child('xs:extension', false, true);
      if Extension <> nil then
      begin
        BaseName := Extension.AttributeString('base');

        // create and add TIfcComplexType instance
        ComplexType := TIfcComplexType.Create;
        ComplexType.Name := TypeName;
        ComplexType.Base := PrefixRemove('Ifc:', BaseName, true);
        IfcTypes.Add(ComplexType);
      end;
    end;
  end else
  begin
    //Writeln('IGNORE: Complex type: ', TypeName);
  end;
end;

procedure HandleOtherType(Node: TDomElement);
// var
//   TypeName: String;
begin
  //TypeName := Node.AttributeString('name');
  //Writeln('IGNORE: Other type: ', TypeName);
end;

{ Just like UrlReadXml, but forces encoding from ASCII to UTF-8.
  Reason: IFC XSD uses ASCII encoding,

    <?xml version='1.0' encoding='ASCII'?>

  which causes

    Encoding 'ASCII' is not supported (in file "IFC4X3_ADD2.xsd")

  error from FPC XMLRead (because TXMLDecodingSource.SetEncoding
  does not support ASCII). }
function UrlReadXml_ForceEncodingUtf8(const Url: String): TXmlDocument;
var
  Stream: TStream;
  Str: String;
  NewStream: TStringStream;
begin
  Stream := Download(Url);
  try
    Str := ReadGrowingStreamToDefaultString(Stream);
    Str := StringReplace(Str, 'encoding=''ASCII''', 'encoding=''UTF-8''', []);
    NewStream := TStringStream.Create(Str);
    try
      ReadXmlFile(Result, NewStream);
    finally FreeAndNil(NewStream) end;
  finally FreeAndNil(Stream) end;
end;

var
  Doc: TXmlDocument;
  I: TXMLElementIterator;
  OutputInclude, OutputInterface, OutputImplementation, OutputAddClasses: String;
begin
  DownloadSchema;

  { All global instances are nil, use this to have less nesting in try..finally. }
  try
    ProcessTypes := TStringList.Create;
    ProcessTypes.LoadFromUrl('castle-data:/process_types.txt');

    IfcTypes := TIfcTypeList.Create(true);

    Doc := UrlReadXml_ForceEncodingUtf8(SchemaFile);
    try
      I := Doc.DocumentElement.ChildrenIterator;
      try
        while I.GetNext do
        begin
          if I.Current.TagName8 = 'xs:simpleType' then
            HandleSimpleType(I.Current)
          else
          if I.Current.TagName8 = 'xs:complexType' then
            HandleComplexType(I.Current)
          else
            HandleOtherType(I.Current);
        end;
      finally FreeAndNil(I) end;
    finally FreeAndNil(Doc) end;

    IfcTypes.ResolveAncestors;
    IfcTypes.Sort(TIfcTypeComparer.Construct(
      {$ifdef FPC}@{$endif} IfcTypes.CompareIfcTypes));
    IfcTypes.MakeOutput(OutputInterface, OutputImplementation, OutputAddClasses);

    OutputInclude :=
      '{%MainUnit castleifc.pas}' + NL +
      '{ Auto-generated IFC classes definitions by generate_ifc. }' + NL +
      '{$ifdef read_interface_types}' + NL +
      '//type' + NL +
      OutputInterface +
      '{$endif read_interface_types}' + NL +
      NL +
      '{$ifdef read_implementation}' + NL +
      OutputImplementation + NL +
      '{$endif read_implementation}' + NL +
      NL +
      '{$ifdef read_add_classes}' + NL +
      OutputAddClasses + NL +
      '{$endif read_add_classes}';
    StringToFile(OutputPath, OutputInclude);
  finally
    FreeAndNil(ProcessTypes);
    FreeAndNil(IfcTypes);
  end;
end.
