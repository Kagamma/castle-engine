{%MainUnit castleifc.pas}
{
  Copyright 2024-2024 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ IFC conversion to X3D. }

{$ifdef read_interface_types}

  { Maintains mapping between IFC concepts and X3D nodes.
    Allows to comfortably load IFC file and convert it to X3D multple
    times (using @link(Load), @link(Update), @link(RootNode)).
    Allows also to resolve X3D nodes back to IFC concepts
    (using @link(NodeToProduct)). }
  TCastleIfcMapping = class
  strict private
    FBaseUrl: String;
    FRootNode: TX3DRootNode;

    { Use ObjectPlacementToParentNodes and ChildrenNodesToObjectPlacement
      to move the nodes (change parents) to reflect
      TIfcObjectPlacement.PlacementRelTo instructions. }
    procedure FixParentChildRelationships;

    function CreateRootNode(const Ifc: TIfcFile): TX3DRootNode;
  private
    { Within the CastleIfc unit, this class is a container for information
      and actions useful to all
      node-building routines that build/update X3D stuff from IFC.
      The things below are used by BuildNode methods of IFC classes. }

    type
      TObjectPlacementToParentNodes =
        {$ifdef FPC}specialize{$endif} TDictionary<TIfcObjectPlacement, TTransformNode>;
      TChildrenNodesToObjectPlacement =
        {$ifdef FPC}specialize{$endif} TDictionary<TTransformNode, TIfcObjectPlacement>;
      TShapeToProduct =
        {$ifdef FPC}specialize{$endif} TDictionary<TAbstractShapeNode, TIfcProduct>;

    var
      { Map each encountered TIfcObjectPlacement to an X3D TTransformNode. }
      ObjectPlacementToParentNodes: TObjectPlacementToParentNodes;

      { Map each children node (TTransformNode) to a desired parent,
        expressed as TIfcObjectPlacement.
        Together, ObjectPlacementToParentNodes and ChildrenNodesToObjectPlacement
        allow to set the visual transformation (parent-child relationships
        between X3D nodes) to follow IFC TIfcObjectPlacement.PlacementRelTo idea. }
      ChildrenNodesToObjectPlacement: TChildrenNodesToObjectPlacement;

      { Map X3D shape nodes to IFC products. Allows to implement NodeToProduct.
        Use this only to map TShapeNode instances (pointers)
        that definitely exist and are valid.

        Due to how we manage this list (each TCastleIfcMapping.Update
        adds new TShape instances as keys, without removing previous,
        because maybe some previous will survive) we may have invalid
        pointers as keys in this dictionary. }
      ShapeToProduct: TShapeToProduct;

    { BaseUrl should be passed to all X3D nodes created by this class,
      so they have TX3DRootNode.BaseUrl equal to this. }
    property BaseUrl: String read FBaseUrl;
  public
    constructor Create;
    destructor Destroy; override;

    { Load IFC instance (TIfcFile) converting it to a new X3D node
      (available in @link(RootNode)).

      The BaseUrl will be used to resolve relative URLs,
      e.g. texture URLs mentioned in IFC information.

      After calling this (and before destroying this class or calling
      @link(Load) again) remember to free the resulting @link(RootNode),
      it is not freed automatically by this class (because in all practical
      use-cases, you want to keep the X3D node around,
      e.g. to be owned by TCastleScene or freed manually later). }
    procedure Load(const Ifc: TIfcFile; const ABaseUrl: String);

    { Latest X3D root node, built from the latest IFC instance. }
    property RootNode: TX3DRootNode read FRootNode;

    { Update the nodes in @link(RootNode) based on the new IFC contents.
      Call this only after calling @link(Load) once.

      Tries to be efficient and do as little work as possible
      and update X3D graph in @link(RootNode) to reflect the new IFC contents.
      For example, changing a translation in IFC will just change the corresponding
      @link(TTransformNode.Translation), without recreating any X3D nodes. }
    procedure Update(const Ifc: TIfcFile);

    { For a shape node (TAbstractShapeNode), return the corresponding IFC product
      (TIfcProduct descendant, like a TIfcWall, TIfcWindow, TIfcDoor).
      Returns @nil if cannot be determined.
      Assumes that the nodes have been updated to reflect the latest state
      of the IFC classes using @link(Update). }
    function NodeToProduct(const Node: TAbstractShapeNode): TIfcProduct;
  end;

{$endif read_interface_types}

{$ifdef read_interface}

{ Convert IFC file to X3D. }
function IfcToX3D(const Ifc: TIfcFile; const BaseUrl: String): TX3DRootNode;

{ Convert IFC file to X3D. }
function X3DToIfc(const RootNode: TX3DRootNode): TIfcFile;

{$endif read_interface}

{$ifdef read_implementation}

{ Set metadata of a node. }
procedure SetMetadata(const Node: TAbstractNode; const Key, Value: String);
begin
  if Value <> '' then // do not set empty (default in IFC) values, to keep X3D output smaller
  begin
    if Node is TX3DRootNode then
      { TODO: "metadata" of TX3DRootNode is not serialized, but META is.
        Yeah, there are effectively two ways to store metadata in X3D. }
      TX3DRootNode(Node).Meta[Key] := Value
    else
      Node.MetadataString[Key] := Value;
  end;
end;

{ TCastleIfcMapping ---------------------------------------------------------- }

constructor TCastleIfcMapping.Create;
begin
  inherited;
  ShapeToProduct := TShapeToProduct.Create;
end;

destructor TCastleIfcMapping.Destroy;
begin
  FreeAndNil(ShapeToProduct);
  inherited;
end;

procedure TCastleIfcMapping.FixParentChildRelationships;

  { Go up the nodes hierachy, returning direct parent (any TAbstractGroupingNode)
    and possibly non-direct TransformParent (TTransformNode) parent.
    Returns @true and for sure non-nil DirectParent, TransformParent on success.
    On failure returns @false and DirectParent, TransformParent are undefined.

    This way of searching for 2 parents accounts for the fact that
    things in TIfcProduct are wrapped in additional groups related to 'Representation'.
    We don't need to move things out of these groups,
    if ultimately they are placed in the right TTransformNode. }
  function GetParentNode(const Node: TTransformNode;
    out DirectParent: TAbstractGroupingNode; out TransformParent: TTransformNode): Boolean;

    function GetDirectParent(const Node: TAbstractGroupingNode): TAbstractGroupingNode;
    begin
      Result := nil;
      if Node.ParentFieldsCount > 1 then
      begin
        WritelnWarning('IFC', 'Corresponding X3D node has more than one parent field, cannot fix parents to follow placementRelTo', [
          Node.NiceName
        ]);
      end else
      if Node.ParentFieldsCount = 1 then
      begin
        if Node.ParentFields[0].ParentNode is TAbstractGroupingNode then
        begin
          Result := TAbstractGroupingNode(Node.ParentFields[0].ParentNode)
        end else
        begin
          WritelnWarning('IFC', 'Corresponding X3D node has parent field that is not a TAbstractGroupingNode, cannot fix parents to follow placementRelTo', [
            Node.NiceName
          ]);
        end;
      end;
    end;

  var
    PotentialTransformParent: TAbstractGroupingNode;
  begin
    Result := false;
    DirectParent := GetDirectParent(Node);
    TransformParent := nil; // initialize to nil
    if DirectParent = nil then
      Exit; // exit with Result = false

    PotentialTransformParent := DirectParent;
    while not (PotentialTransformParent is TTransformNode) do
    begin
      PotentialTransformParent := GetDirectParent(PotentialTransformParent);
      if PotentialTransformParent = nil then
        Exit; // exit with Result = false
    end;
    Assert(PotentialTransformParent is TTransformNode);
    TransformParent := TTransformNode(PotentialTransformParent);
    Result := true;
  end;

var
  ChildToPlacement:
    {$ifdef FPC}TChildrenNodesToObjectPlacement.TDictionaryPair
    {$else}TPair<TTransformNode, TIfcObjectPlacement>
    {$endif};
  Child, OldParentTransform, NewParent: TTransformNode;
  OldParentDirect: TAbstractGroupingNode;
begin
  for ChildToPlacement in ChildrenNodesToObjectPlacement do
  begin
    Child := ChildToPlacement.Key;
    if GetParentNode(Child, OldParentDirect, OldParentTransform) then
    begin
      if ObjectPlacementToParentNodes.TryGetValue(ChildToPlacement.Value, NewParent) and
         (OldParentTransform <> NewParent) then
      begin
        WritelnLog('IFC', 'Fixing parent of "%s" to be relative to ObjectPlacement GUID "%s" to follow placementRelTo', [
          Child.NiceName,
          ChildToPlacement.Value.GlobalId
        ]);
        Child.KeepExistingBegin; // do not free Child because ref count temporarily drops to zero below
        OldParentDirect.RemoveChildren(Child);
        NewParent.AddChildren(Child);
        Child.KeepExistingEnd;
      end;
    end;
  end;
end;

function TCastleIfcMapping.CreateRootNode(const Ifc: TIfcFile): TX3DRootNode;
begin
  { Do not do call ShapeToProduct.Clear, as older shapes still exist,
    and (due to how smart TCastleIfcMapping.Update works) may stil exist.
    So they should still map to IFC products.
    If we would do

      ShapeToProduct.Clear; // will be reinitialized by BuildNode methods

    now, our NodeToProduct would no longer enable to pick shapes that survived. }

  { Initialize things used only temporarily during Load. }
  ObjectPlacementToParentNodes := TObjectPlacementToParentNodes.Create;
  ChildrenNodesToObjectPlacement := TChildrenNodesToObjectPlacement.Create;
  try
    Result := Ifc.BuildNode(Self);
    FixParentChildRelationships;
  finally
    FreeAndNil(ObjectPlacementToParentNodes);
    FreeAndNil(ChildrenNodesToObjectPlacement);
  end;
end;

procedure TCastleIfcMapping.Load(const Ifc: TIfcFile; const ABaseUrl: String);
begin
  { Node that we don't free previous FRootNode, we don't own it. }
  FBaseUrl := ABaseUrl;
  FRootNode := CreateRootNode(Ifc);
end;

procedure TCastleIfcMapping.Update(const Ifc: TIfcFile);

  function MergeNodesList(const TargetNodes, SourceNodes: TX3DNodeList): Boolean; forward;

  { Merge contents of two nodes, checking also is it possible to merge.
    One or both of the nodes may be @nil.

    When TargetNode and SourceNode are not of the same class
    we return @false (impossible to merge) without any changes.
    Otherwise, we may return @false (if impossible to merge),
    but some undefined changes to TargetNode may be done anyway.
    Or we will make all necessary changes to TargetNode to reflect SourceNode
    and return @true.

    Some of the contents of SourceNode may become referenced from the TargetNode
    structure as an effect of this call.

    When the nodes cannot be merged, returns @false.
    The circumstances of it may change.
    For now, any structural change -> @false.

    TODO:
    In the future, we may add / remove children to reconcile the structural change.
    For now, it would be of little use, as TAbstractGroupingNode.AddChildren
    and the like are not optimized at TCastleSceneCore anyway (they result
    in ChangedAll) so there's little gain from trying to be smart when
    structural changes happen (well, the gain would be "stable node instances",
    but update time would not improve). }
  function MergeNodes(const TargetNode, SourceNode: TX3DNode): Boolean;
  var
    I: Integer;
    TargetField, SourceField: TX3DField;
  begin
    if (TargetNode = nil) <> (SourceNode = nil) then
      Exit(false);

    if TargetNode = nil then
    begin
      Assert(SourceNode = nil);
      Exit(true); // nothing more to do
    end;

    if TargetNode.ClassType <> SourceNode.ClassType then
      Exit(false);

    // load TInlineNode contents before merging
    if TargetNode is TInlineNode then
    begin
      Assert(SourceNode is TInlineNode);
      TInlineNode(TargetNode).LoadInlined(false);
      TInlineNode(SourceNode).LoadInlined(false);
    end;

    // copy TX3DRootNode specials
    if TargetNode is TX3DRootNode then
    begin
      Assert(SourceNode is TX3DRootNode);
      TX3DRootNode(TargetNode).InternalAssignRootNodeProps(TX3DRootNode(SourceNode));
    end;

    // copy TX3DNode stuff
    TargetNode.X3DName := SourceNode.X3DName;
    TargetNode.BaseUrl := SourceNode.BaseUrl;

    // merge VRML 1 children, recursively
    if TargetNode.VRML1ChildrenCount <> SourceNode.VRML1ChildrenCount then
      Exit(false);
    for I := 0 to TargetNode.VRML1ChildrenCount - 1 do
    begin
      if not MergeNodes(TargetNode.VRML1Children[I], SourceNode.VRML1Children[I]) then
        Exit(false);
    end;

    // merge fields; SFNode and MFNode mean merging recursively
    if TargetNode.FieldsCount <> SourceNode.FieldsCount then
      Exit(false);
    for I := 0 to TargetNode.FieldsCount - 1 do
    begin
      TargetField := TargetNode.Fields[I];
      SourceField := SourceNode.Fields[I];
      if TargetField.ClassType <> SourceField.ClassType then
        Exit(false);

      if TargetField is TSFNode then
      begin
        Assert(SourceField is TSFNode);
        if not MergeNodes(TSFNode(TargetField).Value, TSFNode(SourceField).Value) then
          Exit(false);
      end else
      if TargetField is TMFNode then
      begin
        Assert(SourceField is TMFNode);
        if not MergeNodesList(
            TMFNode(TargetField).InternalItems,
            TMFNode(SourceField).InternalItems) then
          Exit(false);
      end else
        TargetNode.Fields[I].Send(SourceNode.Fields[I]);
    end;

    Result := true;
  end;

  { Like MergeNode, but merge all nodes on the lists. }
  function MergeNodesList(const TargetNodes, SourceNodes: TX3DNodeList): Boolean;
  var
    I: Integer;
  begin
    if TargetNodes.Count <> SourceNodes.Count then
      Exit(false);
    for I := 0 to TargetNodes.Count - 1 do
      if not MergeNodes(TargetNodes[I], SourceNodes[I]) then
        Exit(false);
    Result := true;
  end;

  procedure ReplaceRootContents(const TargetRoot, SourceRoot: TX3DRootNode);
  var
    ChildNode: TAbstractChildNode;
    I: Integer;
  begin
    TargetRoot.ClearChildren;
    for I := 0 to SourceRoot.FdChildren.Count - 1 do
    begin
      ChildNode := SourceRoot.FdChildren[I] as TAbstractChildNode;
      TargetRoot.AddChildren(ChildNode);
    end;
    { This is justifiable now when structure changes, e.g. new wall is added.
      Not justifiable when only transformation, like translation, changes. }
    // WritelnLog('IFC', 'TCastleIfcMapping.Update fallback on unoptimal implementation: Replaced root contents');
  end;

var
  NewRootNode: TX3DRootNode;
begin
  NewRootNode := CreateRootNode(Ifc);
  try
    if not MergeNodes(FRootNode, NewRootNode) then
      ReplaceRootContents(FRootNode, NewRootNode);
  finally FreeAndNil(NewRootNode) end;
end;

function TCastleIfcMapping.NodeToProduct(const Node: TAbstractShapeNode): TIfcProduct;
begin
  if not ShapeToProduct.TryGetValue(Node, Result) then
    Result := nil;
end;

{ BuildNode methods implementations ----------------------------------------- }

function TIfcFile.BuildNode(const Mapping: TCastleIfcMapping): TX3DRootNode;
begin
  Result := TX3DRootNode.Create('', Mapping.BaseUrl);
  SetMetadata(Result, 'IFC_Version', Version);
  SetMetadata(Result, 'IFC_SchemaIdentifier', SchemaIdentifier);
  SetMetadata(Result, 'IFC_OriginatingSystem', OriginatingSystem);
  SetMetadata(Result, 'IFC_PreprocessorVersion', PreprocessorVersion);
  SetMetadata(Result, 'IFC_TimeStamp', TimeStamp);

  Result.AddChildren(Project.BuildNode(Mapping));
end;

function TIfcRepresentationItemList.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
var
  RepresentationItem: TIfcRepresentationItem;
  Group: TGroupNode;
  Child: TAbstractChildNode;
begin
  Group := TGroupNode.Create('', Mapping.BaseUrl);
  SetMetadata(Group, 'IFC_ListOfChildren', ClassOfListChildren(Self).ClassName);
  Result := Group;

  for RepresentationItem in Self do
  begin
    Child := RepresentationItem.BuildNode(Mapping, ParentProduct, Appearance);
    if Child <> nil then
      Group.AddChildren(Child);
  end;
end;

function TIfcRepresentationList.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
var
  Representation: TIfcRepresentation;
  Group: TGroupNode;
begin
  Group := TGroupNode.Create('', Mapping.BaseUrl);
  SetMetadata(Group, 'IFC_ListOfChildren', ClassOfListChildren(Self).ClassName);
  Result := Group;

  for Representation in Self do
    Group.AddChildren(Representation.Items.BuildNode(Mapping, ParentProduct, Appearance));
end;

function TIfcProductRepresentation.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
var
  Group: TGroupNode;
begin
  Group := TGroupNode.Create('', Mapping.BaseUrl);
  SetMetadata(Group, 'IFC_ClassName', ClassName);
  SetMetadata(Group, 'IFC_Name', Name);
  SetMetadata(Group, 'IFC_Description', Description);
  Result := Group;

  Group.AddChildren(Representations.BuildNode(Mapping, ParentProduct, Appearance));
end;

function TIfcRelAggregates.BuildNode(const Mapping: TCastleIfcMapping): TAbstractChildNode;
var
  RelatedObject: TIfcObjectDefinition;
  Group: TGroupNode;
begin
  Group := TGroupNode.Create('', Mapping.BaseUrl);
  SetMetadata(Group, 'IFC_ClassName', ClassName);
  SetMetadata(Group, 'IFC_Name', Name);
  SetMetadata(Group, 'IFC_Description', Description);
  Result := Group;

  for RelatedObject in RelatedObjects do
    Group.AddChildren(RelatedObject.BuildNode(Mapping));
end;

function TIfcRelContainedInSpatialStructure.BuildNode(const Mapping: TCastleIfcMapping): TAbstractChildNode;
var
  Product: TIfcProduct;
  Group: TGroupNode;
begin
  Group := TGroupNode.Create('', Mapping.BaseUrl);
  SetMetadata(Group, 'IFC_ClassName', ClassName);
  SetMetadata(Group, 'IFC_Name', Name);
  SetMetadata(Group, 'IFC_Description', Description);
  Result := Group;

  for Product in RelatedElements do
    Group.AddChildren(Product.BuildNode(Mapping));
end;

function TIfcRelVoidsElement.BuildNode(const Mapping: TCastleIfcMapping): TAbstractChildNode;
var
  Group: TGroupNode;
begin
  Group := TGroupNode.Create('', Mapping.BaseUrl);
  SetMetadata(Group, 'IFC_ClassName', ClassName);
  Result := Group;

  if RelatedOpeningElement <> nil then
    Group.AddChildren(RelatedOpeningElement.BuildNode(Mapping));
end;

procedure TIfcCartesianPointList2D.UpdateCoordinate(const Coord: TCoordinateNode);
var
  I: Integer;
begin
  Coord.FdPoint.Count := CoordList.Count;
  for I := 0 to CoordList.Count - 1 do
    Coord.FdPoint.Items[I] := Vector3(CoordList[I], 0);
end;

procedure TIfcCartesianPointList3D.UpdateCoordinate(const Coord: TCoordinateNode);
// var
//   I: Integer;
begin
  Coord.FdPoint.Items.Assign(CoordList);
  // Coord.FdPoint.Count := CoordList.Count;
  // for I := 0 to CoordList.Count - 1 do
  //   Coord.FdPoint.Items[I] := CoordList[I];
end;

{ UpdateCrossSection method overrides ---------------------------------------- }

procedure TIfcCurve.UpdateCrossSection(const Extrusion: TExtrusionNode);
var
  CrossSection: TVector2List;

  procedure HandleIndexedLineSetNode(const IndexedLineSet: TIndexedLineSetNode);
  var
    Coord: TCoordinateNode;
    I, Index: Integer;
  begin
    Coord := IndexedLineSet.Coord as TCoordinateNode;
    Assert(Coord <> nil); // these X3D nodes are build by us, so we know they have Coord
    for I := 0 to IndexedLineSet.FdCoordIndex.Count - 1 do
    begin
      Index := IndexedLineSet.FdCoordIndex.Items[I];
      if Index < 0 then
      begin
        WritelnWarning('IFC', 'TODO: Unsupported IfcIndexedPolyCurve for extrusion cross section (we need to split into multiple X3D Extrusions to handle disjoint sections)');
      end else
      begin
        Assert(Index < Coord.FdPoint.Count);
        CrossSection.Add(Coord.FdPoint.Items[Index].XY);
      end;
    end;
  end;

  procedure HandleLineSetNode(const LineSet: TLineSetNode);
  var
    Coord: TCoordinateNode;
    I: Integer;
  begin
    Coord := LineSet.Coord as TCoordinateNode;
    for I := 0 to Coord.FdPoint.Count - 1 do
      CrossSection.Add(Coord.FdPoint.Items[I].XY);
  end;

var
  Shape: TShapeNode;
  Mapping: TCastleIfcMapping;
begin
  CrossSection := TVector2List.Create;
  try
    Mapping := TCastleIfcMapping.Create;
    try
      Shape := BuildNode(Mapping, nil, nil) as TShapeNode;
      try
        if Shape.Geometry <> nil then
        begin
          if Shape.Geometry is TIndexedLineSetNode then
            HandleIndexedLineSetNode(TIndexedLineSetNode(Shape.Geometry))
          else
          if Shape.Geometry is TLineSetNode then
            HandleLineSetNode(TLineSetNode(Shape.Geometry))
          else
          if Shape.Geometry <> nil then
            WritelnWarning('IFC', 'Unsupported Shape.Geometry class for TIfcCurve.UpdateCrossSection: ' + Shape.Geometry.ClassName);
        end;
      finally FreeIfUnusedAndNil(Shape) end;
    finally FreeAndNil(Mapping) end;

    // actually use our CrossSection contents, this is all we wanted to calculate
    Extrusion.SetCrossSection(CrossSection);
  finally FreeAndNil(CrossSection) end;
end;

procedure TIfcPolyline.UpdateCrossSection(const Extrusion: TExtrusionNode);
var
  CrossSection: TVector2List;
  I: Integer;
begin
  CrossSection := TVector2List.Create;
  try
    CrossSection.Count := Points.Count;
    for I := 0 to Points.Count - 1 do
      CrossSection[I] := Points[I].Coordinates.Value.XY;
    Extrusion.SetCrossSection(CrossSection);
  finally FreeAndNil(CrossSection) end;
end;

{ BuildNode of TIfcRepresentationItem and descendants ------------------------- }

function TIfcRepresentationItem.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
begin
  Result := nil;
end;

function TIfcPolyline.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
var
  Shape: TShapeNode;
  LineSet: TLineSetNode;
  Coord: TCoordinateNode;
  I: Integer;
begin
  Coord := TCoordinateNode.Create('', Mapping.BaseUrl);
  Coord.FdPoint.Count := Points.Count;
  for I := 0 to Points.Count - 1 do
    Coord.FdPoint.Items[I] := Points[I].Coordinates.Value;

  LineSet := TLineSetNode.Create('', Mapping.BaseUrl);
  LineSet.Coord := Coord;
  LineSet.SetVertexCount([Points.Count]);

  Shape := TShapeNode.Create('', Mapping.BaseUrl);
  Shape.Geometry := LineSet;
  // lines are best displayed as unlit geometry, different material would be useful
  // Shape.Appearance := Appearance;
  SetMetadata(Shape, 'IFC_ClassName', ClassName);

  Mapping.ShapeToProduct.AddOrSetValue(Shape, ParentProduct);
  Result := Shape;
end;

function TIfcIndexedPolyCurve.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;

  { Add integers for NewIndexes to Indexes, decrementing all values
    on NewIndexes by 1.
    Useful as IFC indices are 1-based, X3D is 0-based.
    So instead of

      IndexedLineSet.FdCoordIndex.Items.AddRange(LineIndex.Value);

    you must do

      AddRangeDecrement(IndexedLineSet.FdCoordIndex.Items, LineIndex.Value);
  }
  procedure AddRangeDecrement(const Indexes: TInt32List; const NewIndexes: TIntegerList);
  var
    I: Integer;
  begin
    for I := 0 to NewIndexes.Count - 1 do
      Indexes.Add(NewIndexes[I] - 1);
  end;

var
  Shape: TShapeNode;
  IndexedLineSet: TIndexedLineSetNode;
  LineSet: TLineSetNode;
  Coord: TCoordinateNode;
  Segment: TIfcSegmentIndexSelect;
  LineIndex: TIfcLineIndex;
  ArcIndex: TIfcArcIndex;
begin
  Coord := TCoordinateNode.Create('', Mapping.BaseUrl);
  Points.UpdateCoordinate(Coord);

  Shape := TShapeNode.Create('', Mapping.BaseUrl);
  // lines are best displayed as unlit geometry, different material would be useful
  // Shape.Appearance := Appearance;
  SetMetadata(Shape, 'IFC_ClassName', ClassName);

  if Segments.Count = 0 then
  begin
    { IFC spec says that Segments are optional:
      "In the case that the list of Segments is not provided,
      all points in the IfcCartesianPointList are connected by straight
      line segments in the order they appear in the IfcCartesianPointList." }

    LineSet := TLineSetNode.Create('', Mapping.BaseUrl);
    LineSet.Coord := Coord;
    LineSet.SetVertexCount([Coord.FdPoint.Count]);
    Shape.Geometry := LineSet;
  end else
  begin
    IndexedLineSet := TIndexedLineSetNode.Create('', Mapping.BaseUrl);
    IndexedLineSet.Coord := Coord;
    IndexedLineSet.Mode := lmStrip;
    Shape.Geometry := IndexedLineSet;

    for Segment in Segments do
    begin
      if Segment is TIfcLineIndex then
      begin
        LineIndex := TIfcLineIndex(Segment);
        AddRangeDecrement(IndexedLineSet.FdCoordIndex.Items, LineIndex.Value);
        IndexedLineSet.FdCoordIndex.Items.Add(-1);
      end else
      if Segment is TIfcArcIndex then
      begin
        ArcIndex := TIfcArcIndex(Segment);
        AddRangeDecrement(IndexedLineSet.FdCoordIndex.Items, ArcIndex.Value);
        IndexedLineSet.FdCoordIndex.Items.Add(-1);
      end else
        WritelnWarning('IFC', 'Unsupported Segment class: ' + Segment.ClassName);
    end;
  end;

  Mapping.ShapeToProduct.AddOrSetValue(Shape, ParentProduct);
  Result := Shape;
end;

function TIfcExtrudedAreaSolid.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
var
  Extrusion: TExtrusionNode;
  SweptAreaProf: TIfcArbitraryClosedProfileDef;
  Shape: TShapeNode;
begin
  Extrusion := TExtrusionNode.Create('', Mapping.BaseUrl);
  Extrusion.SetSpine([
    TVector3.Zero,
    ExtrudedDirection.DirectionRatios.Value * Depth
  ]);
  if SweptArea is TIfcArbitraryClosedProfileDef then // also checks is it <> nil
  begin
    SweptAreaProf := TIfcArbitraryClosedProfileDef(SweptArea);
    SweptAreaProf.OuterCurve.UpdateCrossSection(Extrusion);
  end else
  if SweptArea <> nil then
    WritelnWarning('IFC', 'Unsupported IfcExtrudedAreaSolid.SweptArea class: ' + SweptArea.ClassName);

  Shape := TShapeNode.Create('', Mapping.BaseUrl);
  Shape.Geometry := Extrusion;
  Shape.Appearance := Appearance;
  SetMetadata(Shape, 'IFC_ClassName', ClassName);

  Mapping.ShapeToProduct.AddOrSetValue(Shape, ParentProduct);
  Result := Shape;
end;

function TIfcPolygonalFaceSet.BuildNode(const Mapping: TCastleIfcMapping;
  const ParentProduct: TIfcProduct; const Appearance: TAppearanceNode): TAbstractChildNode;
var
  IndexedFaceSet: TIndexedFaceSetNode;
  Coord: TCoordinateNode;
  Face: TIfcIndexedPolygonalFace;
  I, Index: Integer;
  Shape: TShapeNode;
begin
  Coord := TCoordinateNode.Create('', Mapping.BaseUrl);
  if Coordinates <> nil then
    Coord.SetPoint(Coordinates.CoordList);

  IndexedFaceSet := TIndexedFaceSetNode.Create('', Mapping.BaseUrl);
  IndexedFaceSet.Coord := Coord;

  for Face in Faces do
  begin
    for I := 0 to Face.CoordIndex.Count - 1 do
    begin
      Index := Face.CoordIndex[I];
      if Index < PnIndex.Count then
        Index := PnIndex[Index];
      Dec(Index); // IFC indices are 1-based
      IndexedFaceSet.FdCoordIndex.Items.Add(Index);
    end;
    IndexedFaceSet.FdCoordIndex.Items.Add(-1);
  end;

  Shape := TShapeNode.Create('', Mapping.BaseUrl);
  Shape.Geometry := IndexedFaceSet;
  Shape.Appearance := Appearance;
  SetMetadata(Shape, 'IFC_ClassName', ClassName);

  Mapping.ShapeToProduct.AddOrSetValue(Shape, ParentProduct);
  Result := Shape;
end;

{ BuildNode of TIfcObjectDefinition and descendants -------------------------- }

function TIfcObjectDefinition.BuildNode(const Mapping: TCastleIfcMapping): TTransformNode;
var
  RelAggregates: TIfcRelAggregates;
begin
  Result := TTransformNode.Create('', Mapping.BaseUrl);
  SetMetadata(Result, 'IFC_ClassName', ClassName);
  SetMetadata(Result, 'IFC_Name', Name);
  SetMetadata(Result, 'IFC_Description', Description);

  for RelAggregates in IsDecomposedBy do
    Result.AddChildren(RelAggregates.BuildNode(Mapping));
end;

function TIfcSpatialElement.BuildNode(const Mapping: TCastleIfcMapping): TTransformNode;
var
  RelContainedInSpatialStructure: TIfcRelContainedInSpatialStructure;
begin
  Result := inherited;
  for RelContainedInSpatialStructure in ContainsElements do
    Result.AddChildren(RelContainedInSpatialStructure.BuildNode(Mapping));
end;

function TIfcProduct.BuildNode(const Mapping: TCastleIfcMapping): TTransformNode;

  { Derive X3D TAppearanceNode from IFC TIfcObjectDefinition.HasAssociations. }
  function AppearanceFromAssociations(const Associations: TIfcRelAssociatesList): TAppearanceNode;
  begin
    (*
    for Rel in Associations do
    begin
      if Rel is TIfcRelAssociatesMaterial then
      begin
        RelMat := TIfcRelAssociatesMaterial(Rel);
        Result := TAppearanceNode.Create('', Mapping.BaseUrl);
        Result.Material := TPhysicalMaterialNode.Create('', Mapping.BaseUrl);
        // we would like to set Result.Material.BaseColor based on IFC information,
        // but it seems IFC materials don't specify simple color
        Exit;
      end;
    *)

    Result := TAppearanceNode.Create('', Mapping.BaseUrl);
    //Result.Material := TPhysicalMaterialNode.Create('', Mapping.BaseUrl);
    // Phong material looks better alone, with default color and lighting
    Result.Material := TMaterialNode.Create('', Mapping.BaseUrl);
  end;

var
  Appearance: TAppearanceNode;
begin
  Result := inherited;

  if ObjectPlacement <> nil then
    ObjectPlacement.UpdateNode(Mapping, Result);

  if Representation <> nil then
  begin
    // Things inside are affected by given material
    Appearance := AppearanceFromAssociations(HasAssociations);
    try
      Result.AddChildren(Representation.BuildNode(Mapping, Self, Appearance));
    finally
      FreeIfUnusedAndNil(Appearance);
    end;
  end;
end;

function TIfcElement.BuildNode(const Mapping: TCastleIfcMapping): TTransformNode;

  { For all shapes within Node, multiply their main color (RGB) and opacity.
    Also potentially turn shape into unlit. }
  procedure MaterialMultiply(const Node: TAbstractChildNode;
    const Color: TCastleColorRgb; const Opacity: Single;
    const MakeUnlit: Boolean);
  var
    Shape: TShapeNode;
    Group: TAbstractGroupingNode;
    ChildNode: TAbstractChildNode;
    I: Integer;
    MatInfo: TMaterialInfo;
  begin
    if Node is TShapeNode then
    begin
      Shape := TShapeNode(Node);
      if MakeUnlit then
        Shape.Shading := shWireframe;

      if Shape.Appearance = nil then
        Shape.Appearance := TAppearanceNode.Create('', Mapping.BaseUrl);
      Assert(Shape.Appearance <> nil);

      if Shape.Appearance.Material = nil then
        // Material equal to nil implies white unlit in X3D
        Shape.Appearance.Material := TUnlitMaterialNode.Create('', Mapping.BaseUrl);
      Assert(Shape.Appearance.Material <> nil);

      MatInfo := Shape.Appearance.Material.MaterialInfo;
      MatInfo.MainColor := MatInfo.MainColor * Color;
      MatInfo.Opacity := MatInfo.Opacity * Opacity;
      if MakeUnlit then
        MatInfo.EmissiveColor := MatInfo.MainColor;
    end;

    if Node is TAbstractGroupingNode then
    begin
      Group := TAbstractGroupingNode(Node);
      for I := 0 to Group.FdChildren.Count - 1 do
        if Group.FdChildren[I] is TAbstractChildNode then
        begin
          ChildNode := TAbstractChildNode(Group.FdChildren[I]);
          MaterialMultiply(ChildNode, Color, Opacity, MakeUnlit);
        end;
    end;
  end;

const
  LightRedRgb: TCastleColorRgb = (X: 1.0; Y: 0.33; Z: 0.33);
var
  RelVoidsElement: TIfcRelVoidsElement;
  ChildNode: TAbstractChildNode;
begin
  Result := inherited;
  SetMetadata(Result, 'IFC_Tag', Tag);

  { TODO: We don't support CSG for now. So, for debug,

    1. We just display the geometry inside HasOpenings.
       It actually should subtract geometry.
       We mark it light-red, to signify this is not the final geometry.

    2, We set our own geometry (but not the one in HasOpenings)
       to be transparent, to see-through the geometry inside HasOpenings,
       and other geometry that should be visible (e.g. window geometry in wall). }

  if HasOpenings.Count > 0 then
    MaterialMultiply(Result, WhiteRgb, 0.2, false);

  for RelVoidsElement in HasOpenings do
  begin
    ChildNode := RelVoidsElement.BuildNode(Mapping);
    MaterialMultiply(ChildNode, LightRedRgb, 1.0, true);
    Result.AddChildren(ChildNode);
  end;
end;

function TIfcContext.BuildNode(const Mapping: TCastleIfcMapping): TTransformNode;
begin
  Result := inherited;
  SetMetadata(Result, 'IFC_ObjectType', ObjectType);
  SetMetadata(Result, 'IFC_LongName', LongName);
  SetMetadata(Result, 'IFC_Phase', Phase);
end;

{ UpdateNode methods implementations ----------------------------------------- }

procedure TIfcObjectPlacement.UpdateNode(const Mapping: TCastleIfcMapping;
  const Transform: TTransformNode);
begin
  // inherited; // no UpdateNode in ancestor

  Mapping.ObjectPlacementToParentNodes.AddOrSetValue(Self, Transform);
  if PlacementRelTo <> nil then
    Mapping.ChildrenNodesToObjectPlacement.AddOrSetValue(Transform, PlacementRelTo);
end;

procedure TIfcLocalPlacement.UpdateNode(const Mapping: TCastleIfcMapping;
  const Transform: TTransformNode);
begin
  inherited;
  if RelativePlacement <> nil then
    RelativePlacement.UpdateNode(Mapping, Transform);
end;

procedure TIfcPlacement.UpdateNode(const Mapping: TCastleIfcMapping;
  const Transform: TTransformNode);
begin
  // inherited; // no UpdateNode in ancestor

  if Location is TIfcCartesianPoint then
  begin
    Transform.Translation := TIfcCartesianPoint(Location).Coordinates.Value;
  end;
  // TODO: TIfcAxis2Placement2D/3D may define axis and ref direction, should cause rotation?
end;

{ IfcToX3D and back ---------------------------------------------------------- }

function IfcToX3D(const Ifc: TIfcFile; const BaseUrl: String): TX3DRootNode;
var
  Mapping: TCastleIfcMapping;
begin
  Mapping := TCastleIfcMapping.Create;
  try
    Mapping.Load(Ifc, BaseUrl);
    Result := Mapping.RootNode;
  finally FreeAndNil(Mapping) end;
end;

function X3DToIfc(const RootNode: TX3DRootNode): TIfcFile;
begin
  Result := TIfcFile.Create(nil);
  // TODO
end;

{$endif read_implementation}